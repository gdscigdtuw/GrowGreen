import { Dict } from "./types";
export declare const breakpoints: readonly string[];
export declare function mapResponsive(prop: any, mapper: (val: any) => any): any;
export declare function objectToArrayNotation(obj: Dict, bps?: readonly string[]): any[];
export declare function arrayToObjectNotation(values: any[], bps?: readonly string[]): Record<string, any>;
export declare function isResponsiveObjectLike(obj: Dict, bps?: readonly string[]): boolean;
export declare const px: (value: number | string) => string;
export declare function analyzeBreakpoints(breakpoints: Dict): {
    keys: Set<string>;
    normalized: string[];
    isResponsive(test: Dict): boolean;
    asObject: Record<string, any>;
    asArray: string[];
    details: {
        breakpoint: string;
        minW: any;
        maxW: any;
        maxWQuery: string;
        minWQuery: string;
        minMaxQuery: string;
    }[];
    media: (string | null)[];
    toArrayValue(test: Dict): any[];
    toObjectValue(test: any[]): any;
} | null;
export declare type AnalyzeBreakpointsReturn = ReturnType<typeof analyzeBreakpoints>;
/**
 * since breakpoints are defined as custom properties on an array, you may
 * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices
 * and custom breakpoints as string.
 *
 * This function returns true given a custom array property.
 */
export declare const isCustomBreakpoint: (maybeBreakpoint: string) => boolean;
